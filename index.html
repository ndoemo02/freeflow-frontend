<!doctype html>
<html lang="pl">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>FreeFlow — Voice to Order</title>
  <meta name="description" content="Zamów głosem - restauracje, taxi, hotele" />
  <meta name="color-scheme" content="dark light" />
  <meta name="theme-color" content="#ff8a30" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="FreeFlow" />
  <meta name="mobile-web-app-capable" content="yes" />
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="manifest.json" />
  
  <!-- Icons -->
  <link rel="icon" type="image/png" href="images/Freeflow-logo.png" />
  <link rel="apple-touch-icon" href="images/Freeflowlogo.png" />
  
  <!-- Preload critical resources -->
  <link rel="preload" href="images/Background.png" as="image" />
  <link rel="preload" href="images/Freeflowlogo.png" as="image" />
  <script type="module" crossorigin src="assets/index-CHbNu_13.js"></script>
  <link rel="stylesheet" crossorigin href="assets/index-i4BUNEdS.css">
</head>

<body>
  <div id="root"></div>
  
  <script>
    // TTS Interceptor i API failover
    (function() {
      const LEGACY_API_BASE = "https://freeflow-backend-vercel.vercel.app/api";
      const DEFAULT_API_BASE = "https://freeflow-backend.vercel.app/api";

      const normalizeBase = (base) => {
        if (typeof base !== "string") return "";
        let normalized = base;
        while (normalized.endsWith("/")) {
          normalized = normalized.slice(0, -1);
        }
        return normalized;
      };
      const configuredBase = normalizeBase(window.__FREEFLOW_API_BASE);
      const fallbackBase = normalizeBase(DEFAULT_API_BASE);
      const legacyBase = normalizeBase(LEGACY_API_BASE);
      const apiBases = [configuredBase || fallbackBase, legacyBase].filter(
        (base, index, arr) => base && arr.indexOf(base) === index
      );

      let currentAudio = null;

      // Czyści tekst przed wysłaniem do TTS
      function cleanTextForTTS(text) {
        if (!text || typeof text !== "string") return text;

        return text
          .replace(/\b4\b/g, "cztery")
          .replace(/\b9\b/g, "dziewięć")
          .replace(/\b0\b/g, "zero")
          .replace(/\b1\b/g, "jeden")
          .replace(/\b2\b/g, "dwa")
          .replace(/\b3\b/g, "trzy")
          .replace(/\b5\b/g, "pięć")
          .replace(/\b6\b/g, "sześć")
          .replace(/\b7\b/g, "siedem")
          .replace(/\b8\b/g, "osiem")
          .replace(/\*/g, "")
          .replace(/[\*]+/g, "")
          .replace(/\s+/g, " ")
          .trim();
      }

      // Zatrzymuje aktualnie odtwarzane audio
      function stopCurrentAudio() {
        if (currentAudio) {
          try {
            currentAudio.pause();
            currentAudio.currentTime = 0;
          } catch (e) {
            console.log("Nie można zatrzymać audio:", e);
          }
          currentAudio = null;
        }
      }

      // Przechwytuje wywołania Audio
      const OriginalAudio = window.Audio;
      window.Audio = function(src) {
        stopCurrentAudio();
        const audio = new OriginalAudio(src);
        currentAudio = audio;
        return audio;
      };
      if (OriginalAudio && OriginalAudio.prototype) {
        window.Audio.prototype = OriginalAudio.prototype;
      }

      const originalFetch = window.fetch;

      function cloneInit(init) {
        if (!init) return undefined;
        const cloned = { ...init };
        if (typeof Headers !== "undefined" && init.headers instanceof Headers) {
          const headers = new Headers();
          init.headers.forEach((value, key) => headers.append(key, value));
          cloned.headers = headers;
        } else if (init.headers && typeof init.headers === "object") {
          cloned.headers = Array.isArray(init.headers) ? [...init.headers] : { ...init.headers };
        }
        return cloned;
      }

      function sanitizeTTSRequest(init) {
        if (!init || !init.body) return;
        try {
          const body = init.body;
          if (typeof body === "string") {
            const data = JSON.parse(body);
            if (data.input || data.text) {
              stopCurrentAudio();
              if (data.input) {
                data.input = cleanTextForTTS(data.input);
              }
              if (data.text) {
                data.text = cleanTextForTTS(data.text);
              }
              init.body = JSON.stringify(data);
              console.log("TTS tekst wyczyszczony:", data.input || data.text);
            }
          }
        } catch (error) {
          console.log("Nie udało się przetworzyć TTS request:", error);
        }
      }

      window.fetch = async function(input, init) {
        const isRequestInput = input instanceof Request;
        const url = typeof input === "string" ? input : isRequestInput ? input.url : "";
        let options = !isRequestInput && init ? cloneInit(init) : !isRequestInput ? init : undefined;

        if (!isRequestInput && typeof url === "string" && (url.includes("openai") || url.includes("speech") || url.includes("tts"))) {
          sanitizeTTSRequest(options);
        }

        const finalInit = isRequestInput ? init : options;

        if (isRequestInput) {
          return originalFetch.call(this, input, finalInit);
        }

        const shouldFailover = typeof url === "string" && url.startsWith(legacyBase);

        if (!shouldFailover) {
          return originalFetch.call(this, url, finalInit);
        }

        let lastError;
        for (const base of apiBases) {
          const nextUrl = url.replace(legacyBase, base);
          const attemptInit = options ? cloneInit(options) : options;
          try {
            const response = await originalFetch.call(this, nextUrl, attemptInit);
            if (response.ok) {
              if (base !== legacyBase) {
                console.info("FreeFlow API rerouted do:", base);
              }
              return response;
            }
            lastError = new Error(`HTTP ${response.status}`);
            console.warn("FreeFlow API odpowiedziało statusem", response.status, "dla bazowego adresu", base);
          } catch (error) {
            lastError = error;
            console.warn("FreeFlow API błąd połączenia dla bazowego adresu", base, error);
          }
        }

        if (lastError) throw lastError;
        throw new Error("FreeFlow API request failed");
      };

      // Przechwytuje createObjectURL dla audio blob
      const originalCreateObjectURL = URL.createObjectURL;
      URL.createObjectURL = function(blob) {
        if (blob && blob.type && blob.type.startsWith("audio/")) {
          stopCurrentAudio();
        }
        return originalCreateObjectURL.apply(this, arguments);
      };

      console.log("TTS Interceptor załadowany - cyfry i gwiazdki będą filtrowane, audio zsynchronizowane + API failover");
    })();
  </script>
  
</body>
</html>
